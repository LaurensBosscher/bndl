

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>bndl.compute.dataset &mdash; BNDL 0.3.5.dev1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
        <link rel="copyright" title="Copyright" href="../../../copyright.html"/>
    <link rel="top" title="BNDL 0.3.5.dev1 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> BNDL
          

          
          </a>

          
            
            
              <div class="version">
                0.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../compatibility.html">Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../usage/index.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../plugins.html">Plugins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../issues.html">Known issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../copyright.html">Copyright</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Change log</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../development/index.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../internals.html">Internals</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">BNDL</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      
    <li>bndl.compute.dataset</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for bndl.compute.dataset</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">deque</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Sized</span><span class="p">,</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">partial</span><span class="p">,</span> <span class="n">total_ordering</span><span class="p">,</span> <span class="n">reduce</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">islice</span><span class="p">,</span> <span class="n">product</span><span class="p">,</span> <span class="n">chain</span><span class="p">,</span> <span class="n">starmap</span><span class="p">,</span> <span class="n">groupby</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">ceil</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="k">import</span> <span class="n">add</span>
<span class="kn">import</span> <span class="nn">concurrent.futures</span>
<span class="kn">import</span> <span class="nn">gzip</span>
<span class="kn">import</span> <span class="nn">heapq</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">shlex</span>
<span class="kn">import</span> <span class="nn">struct</span>
<span class="kn">import</span> <span class="nn">subprocess</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">weakref</span>

<span class="kn">from</span> <span class="nn">cytoolz.functoolz</span> <span class="k">import</span> <span class="n">compose</span>
<span class="kn">from</span> <span class="nn">cytoolz.itertoolz</span> <span class="k">import</span> <span class="n">pluck</span><span class="p">,</span> <span class="n">take</span>

<span class="kn">from</span> <span class="nn">bndl.compute</span> <span class="k">import</span> <span class="n">cache</span>
<span class="kn">from</span> <span class="nn">bndl.compute.stats</span> <span class="k">import</span> <span class="n">iterable_size</span><span class="p">,</span> <span class="n">Stats</span><span class="p">,</span> <span class="n">MultiVariateStats</span><span class="p">,</span> \
                               <span class="n">sample_with_replacement</span><span class="p">,</span> <span class="n">sample_without_replacement</span>
<span class="kn">from</span> <span class="nn">bndl.execute</span> <span class="k">import</span> <span class="n">TaskCancelled</span><span class="p">,</span> <span class="n">DependenciesFailed</span>
<span class="kn">from</span> <span class="nn">bndl.execute.job</span> <span class="k">import</span> <span class="n">RmiTask</span><span class="p">,</span> <span class="n">Job</span><span class="p">,</span> <span class="n">Task</span>
<span class="kn">from</span> <span class="nn">bndl.execute.scheduler</span> <span class="k">import</span> <span class="n">FailedDependency</span>
<span class="kn">from</span> <span class="nn">bndl.execute.worker</span> <span class="k">import</span> <span class="n">task_context</span><span class="p">,</span> <span class="n">current_worker</span>
<span class="kn">from</span> <span class="nn">bndl.net.connection</span> <span class="k">import</span> <span class="n">NotConnected</span>
<span class="kn">from</span> <span class="nn">bndl.rmi</span> <span class="k">import</span> <span class="n">InvocationException</span><span class="p">,</span> <span class="n">root_exc</span>
<span class="kn">from</span> <span class="nn">bndl.util</span> <span class="k">import</span> <span class="n">strings</span>
<span class="kn">from</span> <span class="nn">bndl.util.callsite</span> <span class="k">import</span> <span class="n">get_callsite</span><span class="p">,</span> <span class="n">callsite</span><span class="p">,</span> <span class="n">set_callsite</span>
<span class="kn">from</span> <span class="nn">bndl.util.collection</span> <span class="k">import</span> <span class="n">is_stable_iterable</span><span class="p">,</span> <span class="n">ensure_collection</span>
<span class="kn">from</span> <span class="nn">bndl.util.exceptions</span> <span class="k">import</span> <span class="n">catch</span>
<span class="kn">from</span> <span class="nn">bndl.util.funcs</span> <span class="k">import</span> <span class="n">identity</span><span class="p">,</span> <span class="n">getter</span><span class="p">,</span> <span class="n">key_or_getter</span><span class="p">,</span> <span class="n">partial_func</span>
<span class="kn">from</span> <span class="nn">bndl.util.hash</span> <span class="k">import</span> <span class="n">portable_hash</span>
<span class="kn">from</span> <span class="nn">bndl.util.hyperloglog</span> <span class="k">import</span> <span class="n">HyperLogLog</span>
<span class="kn">import</span> <span class="nn">cycloudpickle</span> <span class="k">as</span> <span class="nn">cloudpickle</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_as_bytes</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">b</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_as_bytes</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">bit_length</span><span class="p">(),</span> <span class="s1">&#39;little&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;&gt;f&#39;</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;&gt;l&#39;</span><span class="p">,</span> <span class="n">obj</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">bit_length</span><span class="p">(),</span> <span class="s1">&#39;little&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>


<div class="viewcode-block" id="Dataset"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset">[docs]</a><span class="k">class</span> <span class="nc">Dataset</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">cleanup</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">sync_required</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dset_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">src</span> <span class="o">=</span> <span class="n">src</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">dset_id</span> <span class="ow">or</span> <span class="n">strings</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache_provider</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache_locs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_workers_required</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callsite</span> <span class="o">=</span> <span class="n">get_callsite</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>


    <span class="k">def</span> <span class="nf">parts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">()</span>


<div class="viewcode-block" id="Dataset.map"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.map">[docs]</a>    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Transform elements in this dataset one by one.</span>

<span class="sd">        :param func: callable(element)</span>
<span class="sd">            applied to each element of the dataset</span>

<span class="sd">        Any extra \*args or \**kwargs are passed to func (args before element).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">partial_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="n">func</span><span class="p">))</span></div>


<div class="viewcode-block" id="Dataset.starmap"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.starmap">[docs]</a>    <span class="k">def</span> <span class="nf">starmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Variadic form of map.</span>

<span class="sd">        :param func: callable(element)</span>
<span class="sd">            applied to each element of the dataset</span>

<span class="sd">        Any extra \*args or \**kwargs are passed to func (args before element).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">partial_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">starmap</span><span class="p">,</span> <span class="n">func</span><span class="p">))</span></div>


<div class="viewcode-block" id="Dataset.pluck"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.pluck">[docs]</a>    <span class="k">def</span> <span class="nf">pluck</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Pluck indices from each of the elements in this dataset.</span>

<span class="sd">        :param ind: obj or list</span>
<span class="sd">            The indices to pluck with.</span>
<span class="sd">        :param default: obj</span>
<span class="sd">            A default value.</span>

<span class="sd">        For example::</span>

<span class="sd">            &gt;&gt;&gt; ctx.collection([&#39;abc&#39;]*10).pluck(1).collect()</span>
<span class="sd">            [&#39;b&#39;, &#39;b&#39;, &#39;b&#39;, &#39;b&#39;, &#39;b&#39;, &#39;b&#39;, &#39;b&#39;, &#39;b&#39;, &#39;b&#39;, &#39;b&#39;]</span>
<span class="sd">            &gt;&gt;&gt; ctx.collection([&#39;abc&#39;]*10).pluck([1,2]).collect()</span>
<span class="sd">            [(&#39;b&#39;, &#39;c&#39;), (&#39;b&#39;, &#39;c&#39;), (&#39;b&#39;, &#39;c&#39;), (&#39;b&#39;, &#39;c&#39;), (&#39;b&#39;, &#39;c&#39;), (&#39;b&#39;, &#39;c&#39;), (&#39;b&#39;, &#39;c&#39;), (&#39;b&#39;, &#39;c&#39;), (&#39;b&#39;, &#39;c&#39;), (&#39;b&#39;, &#39;c&#39;)]</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;default&#39;</span><span class="p">:</span> <span class="n">default</span><span class="p">}</span> <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">pluck</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>


<div class="viewcode-block" id="Dataset.flatmap"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.flatmap">[docs]</a>    <span class="k">def</span> <span class="nf">flatmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Transform the elements in this dataset into iterables and chain them</span>
<span class="sd">        within each of the partitions.</span>

<span class="sd">        :param func: callable(element)</span>
<span class="sd">            The transformation to apply. Defaults to none; i.e. consider the</span>
<span class="sd">            elements in this the iterables to chain.</span>

<span class="sd">        Any extra \*args or \**kwargs are passed to func (args before element).</span>

<span class="sd">        For example::</span>

<span class="sd">            &gt;&gt;&gt; &#39;&#39;.join(ctx.collection([&#39;abc&#39;]*10).flatmap().collect())</span>
<span class="sd">            &#39;abcabcabcabcabcabcabcabcabcabc&#39;</span>

<span class="sd">        or::</span>

<span class="sd">            &gt;&gt;&gt; import string</span>
<span class="sd">            &gt;&gt;&gt; &#39;&#39;.join(ctx.range(5).flatmap(lambda i: string.ascii_lowercase[i-1]*i).collect())</span>
<span class="sd">            &#39;abbcccdddd&#39;</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">iterables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">if</span> <span class="n">func</span> <span class="k">else</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">iterables</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.map_partitions"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.map_partitions">[docs]</a>    <span class="k">def</span> <span class="nf">map_partitions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Transform the partitions of this dataset.</span>

<span class="sd">        :param func: callable(iterator)</span>
<span class="sd">            The transformation to apply.</span>

<span class="sd">        Any extra \*args or \**kwargs are passed to func (args before element).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">partial_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions_with_part</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">,</span> <span class="n">iterator</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">iterator</span><span class="p">))</span></div>


<div class="viewcode-block" id="Dataset.map_partitions_with_index"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.map_partitions_with_index">[docs]</a>    <span class="k">def</span> <span class="nf">map_partitions_with_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Transform the partitions - with their index - of this dataset.</span>

<span class="sd">        :param func: callable(\*args, index, iterator, \**kwargs)</span>
<span class="sd">            The transformation to apply on the partition index and the iterator</span>
<span class="sd">            over the partition&#39;s elements.</span>

<span class="sd">        Any extra \*args or \**kwargs are passed to func (args before index and iterator).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">partial_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions_with_part</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">,</span> <span class="n">iterator</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">idx</span><span class="p">,</span> <span class="n">iterator</span><span class="p">))</span></div>


<div class="viewcode-block" id="Dataset.map_partitions_with_part"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.map_partitions_with_part">[docs]</a>    <span class="k">def</span> <span class="nf">map_partitions_with_part</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Transform the partitions - with the source partition object as argument - of</span>
<span class="sd">        this dataset.</span>

<span class="sd">        :param func: callable(\*args, partition, iterator, \**kwargs)</span>
<span class="sd">            The transformation to apply on the partition object and the iterator</span>
<span class="sd">            over the partition&#39;s elements.</span>

<span class="sd">        Any extra \*args or \**kwargs are passed to func (args before partition and iterator).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">partial_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TransformingDataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.pipe"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.pipe">[docs]</a>    <span class="k">def</span> <span class="nf">pipe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="n">reader</span><span class="o">=</span><span class="n">io</span><span class="o">.</span><span class="n">IOBase</span><span class="o">.</span><span class="n">readlines</span><span class="p">,</span> <span class="n">writer</span><span class="o">=</span><span class="n">io</span><span class="o">.</span><span class="n">IOBase</span><span class="o">.</span><span class="n">writelines</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Transform partitions by sending partition data to an external program over stdout/stdin and</span>
<span class="sd">        read back its output.</span>

<span class="sd">        Args:</span>
<span class="sd">            command (str): Command to execute (is &#39;parsed&#39; by ``shlex.split``).</span>
<span class="sd">            reader (callable -&gt; iterable): Called with :attr:`subprocess.Popen.stdout` to read and</span>
<span class="sd">                iterate over the program&#39;s output.</span>
<span class="sd">            writer (callable): Called with :attr:`subprocess.Popen.stdin` and the partition</span>
<span class="sd">                iterable to write the partition&#39;s contents to the program.</span>
<span class="sd">                iterate over the program&#39;s output.</span>
<span class="sd">            **opts: Options to provide to :class:`subprocess.Popen`.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">command</span> <span class="o">=</span> <span class="n">shlex</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">pipe_partition</span><span class="p">(</span><span class="n">partition</span><span class="p">):</span>
            <span class="n">opts</span><span class="p">[</span><span class="s1">&#39;stdin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span>
            <span class="n">opts</span><span class="p">[</span><span class="s1">&#39;stdout&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span>
            <span class="n">proc</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">Popen</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">)</span>

            <span class="n">failure</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
            <span class="k">def</span> <span class="nf">write_partition</span><span class="p">(</span><span class="n">failure</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">writer</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">stdin</span><span class="p">,</span> <span class="n">partition</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                    <span class="n">failure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">exc</span>
                <span class="k">finally</span><span class="p">:</span>
                    <span class="n">proc</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

            <span class="n">writer_thread</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">write_partition</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">failure</span><span class="p">])</span>
            <span class="n">writer_thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="k">yield from</span> <span class="n">reader</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>
            <span class="n">writer_thread</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

            <span class="n">failure</span> <span class="o">=</span> <span class="n">failure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">failure</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">failure</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="n">pipe_partition</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.glom"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.glom">[docs]</a>    <span class="k">def</span> <span class="nf">glom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Transforms each partition into a partition with one element being the</span>
<span class="sd">        contents of the partition as a &#39;stable iterable&#39; (e.g. a list).</span>

<span class="sd">        See the bndl.util.collection.is_stable_iterable function for details on</span>
<span class="sd">        what constitutes a stable iterable.</span>

<span class="sd">        Example::</span>

<span class="sd">            &gt;&gt;&gt; ctx.range(10, pcount=4).map_partitions(list).glom().collect()</span>
<span class="sd">            [[0, 1], [2, 3, 4], [5, 6], [7, 8, 9]]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="p">(</span><span class="n">ensure_collection</span><span class="p">(</span><span class="n">p</span><span class="p">),))</span></div>


<div class="viewcode-block" id="Dataset.concat"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.concat">[docs]</a>    <span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sep</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Concattenate the elements in this dataset with sep</span>

<span class="sd">        Args:</span>
<span class="sd">            sep (str, bytes or bytarray): the value to use to concattenate.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">part</span><span class="p">):</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">()</span>
                <span class="n">write</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">write</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">part</span><span class="p">:</span>
                    <span class="n">write</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="n">write</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">getvalue</span><span class="p">(),)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="p">(</span><span class="nb">bytes</span><span class="p">,</span> <span class="nb">bytearray</span><span class="p">)):</span>
            <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">part</span><span class="p">):</span>
                <span class="n">buffer</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>
                <span class="n">extend</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">.</span><span class="n">extend</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">part</span><span class="p">:</span>
                    <span class="n">extend</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="n">extend</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">buffer</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sep must be str, bytes or bytearray, not </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">sep</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="n">f</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">parse_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
        <span class="kn">from</span> <span class="nn">bndl.compute</span> <span class="k">import</span> <span class="n">dataframes</span>

        <span class="k">def</span> <span class="nf">as_df</span><span class="p">(</span><span class="n">part</span><span class="p">):</span>
            <span class="n">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">part</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">dfs</span><span class="p">))</span>
        <span class="n">dsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="n">as_df</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sample</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;names&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">columns</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dataframes</span><span class="o">.</span><span class="n">DistributedDataFrame</span><span class="p">(</span><span class="n">dsets</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">],</span> <span class="n">columns</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sample</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="p">()),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dataframes</span><span class="o">.</span><span class="n">DistributedDataFrame</span><span class="o">.</span><span class="n">from_sample</span><span class="p">(</span><span class="n">dsets</span><span class="p">,</span> <span class="n">sample</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">as_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">bndl.compute</span> <span class="k">import</span> <span class="n">dataframes</span>
        <span class="k">return</span> <span class="n">dataframes</span><span class="o">.</span><span class="n">DistributedDataFrame</span><span class="o">.</span><span class="n">from_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<div class="viewcode-block" id="Dataset.filter"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.filter">[docs]</a>    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Filter out elements from this dataset</span>

<span class="sd">        Args:</span>
<span class="sd">            func (callable(element)): The test function to filter this dataset with. An element is</span>
<span class="sd">                retained in the dataset if the test is positive.</span>

<span class="sd">        Any extra \*args or \**kwargs are passed to func (args before element).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">func</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="nb">filter</span><span class="p">,</span> <span class="n">func</span><span class="p">))</span></div>


<div class="viewcode-block" id="Dataset.starfilter"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.starfilter">[docs]</a>    <span class="k">def</span> <span class="nf">starfilter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Variadic form of Dataset.filter.</span>

<span class="sd">        :param func: callable(\*element)</span>
<span class="sd">            The test function to filter this dataset with. An element is</span>
<span class="sd">            retained in the dataset if the test is positive. The element is</span>
<span class="sd">            provided as star args.</span>

<span class="sd">        Any extra \*args or \**kwargs are passed to func (args before element).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">partial_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="p">(</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">p</span> <span class="k">if</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)))</span></div>


<div class="viewcode-block" id="Dataset.mask_partitions"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.mask_partitions">[docs]</a>    <span class="k">def</span> <span class="nf">mask_partitions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        TODO</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">MaskedDataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.key_by"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.key_by">[docs]</a>    <span class="k">def</span> <span class="nf">key_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Prepend the elements in this dataset with a key.</span>

<span class="sd">        The resulting dataset will consist of K,V tuples.</span>

<span class="sd">        :param key: callable(element)</span>
<span class="sd">            The transformation of the element which, when applied, provides the</span>
<span class="sd">            key value.</span>

<span class="sd">        Example::</span>

<span class="sd">            &gt;&gt;&gt; import string</span>
<span class="sd">            &gt;&gt;&gt; ctx.range(5).key_by(lambda i: string.ascii_lowercase[i]).collect()</span>
<span class="sd">            [(&#39;a&#39;, 0), (&#39;b&#39;, 1), (&#39;c&#39;, 2), (&#39;d&#39;, 3), (&#39;e&#39;, 4)]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="p">((</span><span class="n">key</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">p</span><span class="p">))</span></div>


<div class="viewcode-block" id="Dataset.with_value"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.with_value">[docs]</a>    <span class="k">def</span> <span class="nf">with_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Create a dataset of K,V tuples with the elements of this dataset as K</span>
<span class="sd">        and V from the given value.</span>

<span class="sd">        :param val: callable(element) or obj</span>
<span class="sd">            If val is a callable, it will be applied to the elements of this</span>
<span class="sd">            dataset and the return values will be the values. If val is a plain</span>
<span class="sd">            object, it will be used as a constant value for each element.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; ctx.collection(&#39;abcdef&#39;).with_value(1).collect()</span>
<span class="sd">            [(&#39;a&#39;, 1), (&#39;b&#39;, 1), (&#39;c&#39;, 1), (&#39;d&#39;, 1), (&#39;e&#39;, 1), (&#39;f&#39;, 1)]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">val</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">p</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">p</span><span class="p">))</span></div>


<div class="viewcode-block" id="Dataset.key_by_id"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.key_by_id">[docs]</a>    <span class="k">def</span> <span class="nf">key_by_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Key the elements of this data set with a unique integer id.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; ctx.collection([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;], pcount=2).key_by_id().collect()</span>
<span class="sd">            [(0, &#39;a&#39;), (2, &#39;b&#39;), (4, &#39;c&#39;), (1, &#39;d&#39;), (3, &#39;e&#39;)]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">())</span>
        <span class="k">def</span> <span class="nf">with_id</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">part</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">((</span><span class="n">idx</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">part</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions_with_index</span><span class="p">(</span><span class="n">with_id</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.key_by_idx"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.key_by_idx">[docs]</a>    <span class="k">def</span> <span class="nf">key_by_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Key the elements of this data set with their index.</span>

<span class="sd">        This operation starts a job when the data set contains more than 1</span>
<span class="sd">        partition to calculate offsets for each of the partitions. Use</span>
<span class="sd">        key_by_id or cache the data set to speed up processing.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; ctx.collection([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]).key_by_idx().collect()</span>
<span class="sd">            [(0, &#39;a&#39;), (1, &#39;b&#39;), (2, &#39;c&#39;), (3, &#39;d&#39;), (4, &#39;e&#39;)]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">size</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="p">(</span><span class="n">iterable_size</span><span class="p">(</span><span class="n">p</span><span class="p">),))</span><span class="o">.</span><span class="n">collect</span><span class="p">():</span>
                <span class="n">offsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">offsets</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">with_idx</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">part</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">offsets</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions_with_index</span><span class="p">(</span><span class="n">with_idx</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.keys"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.keys">[docs]</a>    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Pluck the keys from this dataset.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; ctx.collection([(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3)]).keys().collect()</span>
<span class="sd">            [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pluck</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.values"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.values">[docs]</a>    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Pluck the values from this dataset.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; ctx.collection([(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3)]).keys().collect()</span>
<span class="sd">            [1, 2, 3]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pluck</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.map_keys"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.map_keys">[docs]</a>    <span class="k">def</span> <span class="nf">map_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Transform the keys of this dataset.</span>

<span class="sd">        :param func: callable(key)</span>
<span class="sd">            Transformation to apply to the keys</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">partial_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="p">((</span><span class="n">func</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">p</span><span class="p">))</span></div>


<div class="viewcode-block" id="Dataset.map_values"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.map_values">[docs]</a>    <span class="k">def</span> <span class="nf">map_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Transform the values of this dataset.</span>

<span class="sd">        :param func: callable(value)</span>
<span class="sd">            Transformation to apply to the values</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">partial_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">func</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">p</span><span class="p">))</span></div>


<div class="viewcode-block" id="Dataset.pluck_values"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.pluck_values">[docs]</a>    <span class="k">def</span> <span class="nf">pluck_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Pluck indices from each of the values in this dataset of (key, value) pairs.</span>

<span class="sd">        :param ind: obj or list</span>
<span class="sd">            The indices to pluck with.</span>
<span class="sd">        :param default: obj</span>
<span class="sd">            A default value.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;default&#39;</span><span class="p">:</span> <span class="n">default</span><span class="p">}</span> <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_values</span><span class="p">(</span><span class="k">lambda</span> <span class="n">value</span><span class="p">:</span> <span class="n">pluck</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>


<div class="viewcode-block" id="Dataset.flatmap_values"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.flatmap_values">[docs]</a>    <span class="k">def</span> <span class="nf">flatmap_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param func: callable(value) or None</span>
<span class="sd">            The callable which flattens the values of this dataset or None in</span>
<span class="sd">            order to use the values as iterables to flatten.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">partial_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()</span><span class="o">.</span><span class="n">flatmap</span><span class="p">(</span><span class="n">func</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.filter_bykey"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.filter_bykey">[docs]</a>    <span class="k">def</span> <span class="nf">filter_bykey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Filter the dataset by testing the keys.</span>

<span class="sd">        :param func: callable(key)</span>
<span class="sd">            The test to apply to the keys. When positive, the key, value tuple</span>
<span class="sd">            will be retained.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">func</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">partial_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="p">(</span><span class="n">kv</span> <span class="k">for</span> <span class="n">kv</span> <span class="ow">in</span> <span class="n">p</span> <span class="k">if</span> <span class="n">func</span><span class="p">(</span><span class="n">kv</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="p">(</span><span class="n">kv</span> <span class="k">for</span> <span class="n">kv</span> <span class="ow">in</span> <span class="n">p</span> <span class="k">if</span> <span class="n">kv</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span></div>


<div class="viewcode-block" id="Dataset.filter_byvalue"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.filter_byvalue">[docs]</a>    <span class="k">def</span> <span class="nf">filter_byvalue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Filter the dataset by testing the values.</span>

<span class="sd">        :param func: callable(value)</span>
<span class="sd">            The test to apply to the values. When positive, the key, value tuple</span>
<span class="sd">            will be retained.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">func</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">partial_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="p">(</span><span class="n">kv</span> <span class="k">for</span> <span class="n">kv</span> <span class="ow">in</span> <span class="n">p</span> <span class="k">if</span> <span class="n">func</span><span class="p">(</span><span class="n">kv</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="p">(</span><span class="n">kv</span> <span class="k">for</span> <span class="n">kv</span> <span class="ow">in</span> <span class="n">p</span> <span class="k">if</span> <span class="n">kv</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span></div>


    <span class="nd">@callsite</span><span class="p">()</span>
<div class="viewcode-block" id="Dataset.nlargest"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.nlargest">[docs]</a>    <span class="k">def</span> <span class="nf">nlargest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Take the num largest elements from this dataset.</span>

<span class="sd">        :param num: int</span>
<span class="sd">            The number of elements to take.</span>
<span class="sd">        :param key: callable(element) or None</span>
<span class="sd">            The (optional) key to apply when ordering elements.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_take_ordered</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">heapq</span><span class="o">.</span><span class="n">nlargest</span><span class="p">)</span></div>


    <span class="nd">@callsite</span><span class="p">()</span>
<div class="viewcode-block" id="Dataset.nsmallest"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.nsmallest">[docs]</a>    <span class="k">def</span> <span class="nf">nsmallest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Take the num smallest elements from this dataset.</span>

<span class="sd">        :param num: int</span>
<span class="sd">            The number of elements to take.</span>
<span class="sd">        :param key: callable(element) or None</span>
<span class="sd">            The (optional) key to apply when ordering elements.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_take_ordered</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">heapq</span><span class="o">.</span><span class="n">nsmallest</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_take_ordered</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">taker</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">key_or_getter</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">taker</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">icollect</span><span class="p">())</span>


<div class="viewcode-block" id="Dataset.nsmallest_by_key"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.nsmallest_by_key">[docs]</a>    <span class="k">def</span> <span class="nf">nsmallest_by_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Shuffle and keep only the num smallest elements for each key.&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_take_ordered_by_key</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">heapq</span><span class="o">.</span><span class="n">nsmallest</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.nlargest_by_key"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.nlargest_by_key">[docs]</a>    <span class="k">def</span> <span class="nf">nlargest_by_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Shuffle and keep only the num largest elements for each key.&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_take_ordered_by_key</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">heapq</span><span class="o">.</span><span class="n">nlargest</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_take_ordered_by_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">taker</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">local</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">taker</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">comb</span><span class="p">(</span><span class="n">iterables</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">taker</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">iterables</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate_by_key</span><span class="p">(</span><span class="n">local</span><span class="p">,</span> <span class="n">comb</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">)</span>


<div class="viewcode-block" id="Dataset.histogram"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.histogram">[docs]</a>    <span class="k">def</span> <span class="nf">histogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Compute the histogram of a data set.</span>

<span class="sd">        :param bins: int or sequence</span>
<span class="sd">            The bins to use in computing the histogram; either an int to indicate the number of</span>
<span class="sd">            bins between the minimum and maximum of this data set, or a sorted sequence of unique</span>
<span class="sd">            numbers to be used as edges of the bins.</span>
<span class="sd">        :return: A (np.array, np.array) tuple where the first array is the histogram and the</span>
<span class="sd">            second array the (edges of the) bins.</span>

<span class="sd">        The function behaves similarly to numpy.histogram, but only supports counts per bin (no</span>
<span class="sd">        weights or density/normalization). The resulting histogram and bins should match</span>
<span class="sd">        numpy.histogram very closely.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; ctx.collection([1, 2, 1]).histogram([0, 1, 2, 3])</span>
<span class="sd">            (array([0, 2, 1]), array([0, 1, 2, 3]))</span>
<span class="sd">            &gt;&gt;&gt; ctx.range(4).histogram(np.arange(5))</span>
<span class="sd">            (array([1, 1, 1, 1]), array([0, 1, 2, 3, 4]))</span>

<span class="sd">            &gt;&gt;&gt; ctx.range(4).histogram(5)</span>
<span class="sd">            (array([1, 1, 0, 1, 1]), array([ 0. ,  0.6,  1.2,  1.8,  2.4,  3. ]))</span>
<span class="sd">            &gt;&gt;&gt; ctx.range(4).histogram()</span>
<span class="sd">            (array([1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),</span>
<span class="sd">             array([ 0. ,  0.3,  0.6,  0.9,  1.2,  1.5,  1.8,  2.1,  2.4,  2.7,  3. ]))</span>

<span class="sd">            &gt;&gt;&gt; dset = ctx.collection([1,2,1,3,2,4])</span>
<span class="sd">            &gt;&gt;&gt; hist, bins = dset.histogram()</span>
<span class="sd">            &gt;&gt;&gt; hist</span>
<span class="sd">            array([2, 0, 0, 2, 0, 0, 1, 0, 0, 1])</span>
<span class="sd">            &gt;&gt;&gt; hist.sum() == dset.count()</span>
<span class="sd">            True</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">bins</span> <span class="o">&gt;=</span> <span class="mi">1</span>
            <span class="k">with</span> <span class="n">set_callsite</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;histogram.stats&#39;</span><span class="p">):</span>
                <span class="n">stats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">stats</span><span class="o">.</span><span class="n">min</span> <span class="o">==</span> <span class="n">stats</span><span class="o">.</span><span class="n">max</span> <span class="ow">or</span> <span class="n">bins</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">stats</span><span class="o">.</span><span class="n">count</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">stats</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">stats</span><span class="o">.</span><span class="n">max</span><span class="p">])</span>
            <span class="n">step</span> <span class="o">=</span> <span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">max</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">min</span><span class="p">)</span> <span class="o">/</span> <span class="n">bins</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="o">.</span><span class="n">min</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">step</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bins</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="n">stats</span><span class="o">.</span><span class="n">max</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">bins</span><span class="p">))</span>

        <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="k">lambda</span> <span class="n">part</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">part</span><span class="p">),</span> <span class="n">bins</span><span class="p">)[</span><span class="mi">0</span><span class="p">],))</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">add</span><span class="p">),</span> <span class="n">bins</span></div>


<div class="viewcode-block" id="Dataset.aggregate"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.aggregate">[docs]</a>    <span class="k">def</span> <span class="nf">aggregate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">local</span><span class="p">,</span> <span class="n">comb</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Collect an aggregate of this dataset, where the aggregate is determined</span>
<span class="sd">        by a local aggregation and a global combination.</span>

<span class="sd">        :param local: callable(partition)</span>
<span class="sd">            Function to apply on the partition iterable</span>
<span class="sd">        :param comb: callable</span>
<span class="sd">            Function to combine the results from local. If None, the local</span>
<span class="sd">            callable will be applied.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="p">(</span><span class="n">local</span><span class="p">(</span><span class="n">p</span><span class="p">),))</span><span class="o">.</span><span class="n">icollect</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">comb</span> <span class="ow">or</span> <span class="n">local</span><span class="p">)(</span><span class="n">parts</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;dataset is empty&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.combine"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.combine">[docs]</a>    <span class="k">def</span> <span class="nf">combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="n">merge_value</span><span class="p">,</span> <span class="n">merge_combs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Aggregate the dataset by merging element-wise starting with a zero</span>
<span class="sd">        value and finally merge the intermediate results.</span>

<span class="sd">        :param zero: obj</span>
<span class="sd">            The object to merge values into.</span>
<span class="sd">        :param merge_value:</span>
<span class="sd">            The operation to merge an object into intermediate value (which</span>
<span class="sd">            initially is the zero value).</span>
<span class="sd">        :param merge_combs:</span>
<span class="sd">            The operation to pairwise combine the intermediate values into one</span>
<span class="sd">            final value.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; strings = ctx.range(1000*1000).map(lambda i: i%1000).map(str)</span>
<span class="sd">            &gt;&gt;&gt; sorted(strings.combine(set(), lambda s, e: s.add(e) or s, lambda a, b: a|b)))</span>
<span class="sd">            [&#39;0&#39;,</span>
<span class="sd">             &#39;1&#39;,</span>
<span class="sd">             ...</span>
<span class="sd">             &#39;998&#39;,</span>
<span class="sd">             &#39;999&#39;]</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">def</span> <span class="nf">_local</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="n">merge_value</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">_local</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">reduce</span><span class="p">,</span> <span class="n">merge_combs</span><span class="p">))</span></div>


<div class="viewcode-block" id="Dataset.reduce"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.reduce">[docs]</a>    <span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reduction</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Reduce the dataset into a final element by applying a pairwise</span>
<span class="sd">        reduction as with functools.reduce(...)</span>

<span class="sd">        :param reduction: The reduction to apply.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; ctx.range(100).reduce(lambda a,b: a+b)</span>
<span class="sd">            4950</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">reduce</span><span class="p">,</span> <span class="n">reduction</span><span class="p">))</span></div>


<div class="viewcode-block" id="Dataset.tree_aggregate"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.tree_aggregate">[docs]</a>    <span class="k">def</span> <span class="nf">tree_aggregate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">local</span><span class="p">,</span> <span class="n">comb</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Tree-wise aggregation by first applying local on each partition and</span>
<span class="sd">        subsequently shuffling the data across workers in depth rounds and for</span>
<span class="sd">        each round aggregating the data by applying comb.</span>

<span class="sd">        :param local: func(iterable)</span>
<span class="sd">            The aggregation function to apply to each partition.</span>
<span class="sd">        :param comb:</span>
<span class="sd">            The function to apply in order to combine aggregated partitions.</span>
<span class="sd">        :param depth:</span>
<span class="sd">            The number of iterations to apply the aggregation in.</span>
<span class="sd">        :param scale: int or None (default)</span>
<span class="sd">            The factor by which to reduce the partition count in each round. If</span>
<span class="sd">            None, the step is chosen such that each reduction of intermediary</span>
<span class="sd">            results is roughly of the same size (the branching factor in the</span>
<span class="sd">            tree is the same across the entire tree).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">depth</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">local</span><span class="p">,</span> <span class="n">comb</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">comb</span><span class="p">:</span>
            <span class="n">comb</span> <span class="o">=</span> <span class="n">local</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">scale</span><span class="p">:</span>
            <span class="n">pcount</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">())</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="n">pcount</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">depth</span><span class="p">))),</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">agg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions_with_index</span><span class="p">(</span><span class="k">lambda</span> <span class="n">idx</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="p">[(</span><span class="n">idx</span> <span class="o">%</span> <span class="n">pcount</span><span class="p">,</span> <span class="n">local</span><span class="p">(</span><span class="n">p</span><span class="p">))])</span>

        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">depth</span><span class="p">):</span>
            <span class="n">agg</span> <span class="o">=</span> <span class="n">agg</span><span class="o">.</span><span class="n">_group_by_key</span><span class="p">(</span><span class="n">pcount</span><span class="o">=</span><span class="n">pcount</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">)</span><span class="o">.</span><span class="n">map_values</span><span class="p">(</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">comb</span><span class="p">(</span><span class="n">pluck</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">v</span><span class="p">)))</span>
            <span class="n">pcount</span> <span class="o">//=</span> <span class="n">scale</span>
            <span class="k">if</span> <span class="n">pcount</span> <span class="o">&lt;</span> <span class="n">scale</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">agg</span> <span class="o">=</span> <span class="n">agg</span><span class="o">.</span><span class="n">map_keys</span><span class="p">(</span><span class="k">lambda</span> <span class="n">idx</span><span class="p">,</span> <span class="p">:</span> <span class="n">idx</span> <span class="o">%</span> <span class="n">pcount</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">comb</span><span class="p">(</span><span class="n">agg</span><span class="o">.</span><span class="n">values</span><span class="p">()</span><span class="o">.</span><span class="n">icollect</span><span class="p">())</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;dataset is empty&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.tree_combine"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.tree_combine">[docs]</a>    <span class="k">def</span> <span class="nf">tree_combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="n">merge_value</span><span class="p">,</span> <span class="n">merge_combs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Tree-wise version of Dataset.combine. See Dataset.tree_aggregate for details.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">def</span> <span class="nf">_local</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="n">merge_value</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_aggregate</span><span class="p">(</span><span class="n">_local</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">reduce</span><span class="p">,</span> <span class="n">merge_combs</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.tree_reduce"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.tree_reduce">[docs]</a>    <span class="k">def</span> <span class="nf">tree_reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reduction</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Tree-wise version of Dataset.reduce. See Dataset.tree_aggregate for details.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_aggregate</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">reduce</span><span class="p">,</span> <span class="n">reduction</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.count"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.count">[docs]</a>    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Count the elements in this dataset.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">iterable_size</span><span class="p">,</span> <span class="nb">sum</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.sum"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.sum">[docs]</a>    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sum the elements in this dataset.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; ctx.collection([&#39;abc&#39;, &#39;def&#39;, &#39;ghi&#39;]).map(len).sum()</span>
<span class="sd">            9</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="nb">sum</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.max"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.max">[docs]</a>    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Take the largest element of this dataset.</span>

<span class="sd">        Args:</span>
<span class="sd">            key (callable(element) or object): The (optional) key to apply in comparing element. If</span>
<span class="sd">            key is an object, it is used to pluck from the element with the given to get the</span>
<span class="sd">            comparison key.</span>

<span class="sd">        Example::</span>

<span class="sd">            &gt;&gt;&gt; ctx.range(10).max()</span>
<span class="sd">            9</span>
<span class="sd">            &gt;&gt;&gt; ctx.range(10).with_value(1).max(0)</span>
<span class="sd">            (9, 1)</span>
<span class="sd">            &gt;&gt;&gt; ctx.range(10).map(lambda i: dict(key=i, val=-i)).max(&#39;val&#39;)</span>
<span class="sd">            {&#39;val&#39;: 0, &#39;key&#39;: 0}</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">key_or_getter</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="nb">max</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span> <span class="k">if</span> <span class="n">key</span> <span class="k">else</span> <span class="nb">max</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.min"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.min">[docs]</a>    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Take the smallest element of this dataset.</span>

<span class="sd">        Args:</span>
<span class="sd">            key (callable(element) or object): The (optional) key to apply in comparing element. If</span>
<span class="sd">            key is an object, it is used to pluck from the element with the given to get the</span>
<span class="sd">            comparison key.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">key_or_getter</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span> <span class="k">if</span> <span class="n">key</span> <span class="k">else</span> <span class="nb">min</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.mean"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.mean">[docs]</a>    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate the mean of this dataset.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span></div>


<div class="viewcode-block" id="Dataset.stats"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.stats">[docs]</a>    <span class="k">def</span> <span class="nf">stats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate count, mean, min, max, variance, stdev, skew and kurtosis of this dataset.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">Stats</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">reduce</span><span class="p">,</span> <span class="n">add</span><span class="p">))</span></div>


<div class="viewcode-block" id="Dataset.mvstats"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.mvstats">[docs]</a>    <span class="k">def</span> <span class="nf">mvstats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate count and the multivariate mean, min, max, variance, stdev, skew and kurtosis of</span>
<span class="sd">        this dataset.</span>

<span class="sd">        Args:</span>
<span class="sd">            width (int): The width of the vectors in the dataset to calculate the statistics on. If</span>
<span class="sd">                no width is given, the width is determined through peeking at the first record.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">width</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">width</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">MultiVariateStats</span><span class="p">,</span> <span class="n">width</span><span class="p">),</span> <span class="n">partial</span><span class="p">(</span><span class="n">reduce</span><span class="p">,</span> <span class="n">add</span><span class="p">))</span></div>


<div class="viewcode-block" id="Dataset.union"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.union">[docs]</a>    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">*</span><span class="n">others</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Union this dataset with another</span>

<span class="sd">        :param other: Dataset</span>

<span class="sd">        Example::</span>

<span class="sd">            &gt;&gt;&gt; ctx.range(0, 5).union(ctx.range(5, 10)).collect()</span>
<span class="sd">            [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">UnionDataset</span><span class="p">((</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">+</span> <span class="n">others</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.group_by"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.group_by">[docs]</a>    <span class="k">def</span> <span class="nf">group_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">partitioner</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Group the dataset by a given key function.</span>

<span class="sd">        :param key: callable(element) or obj</span>
<span class="sd">            The callable producing the key to group on or an index / indices</span>
<span class="sd">            for plucking the key from the elements.</span>
<span class="sd">        :param partitioner: callable(element)</span>
<span class="sd">            A callable producing an integer which is used to determine to which</span>
<span class="sd">            partition the group is assigned.</span>
<span class="sd">        :param pcount:</span>
<span class="sd">            The number of partitions to group into.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; ctx.range(10).group_by(lambda i: i%2).collect()</span>
<span class="sd">            [(0, [0, 6, 8, 4, 2]), (1, [1, 3, 7, 9, 5])]</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">key_or_getter</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                    <span class="o">.</span><span class="n">group_by_key</span><span class="p">(</span><span class="n">partitioner</span><span class="o">=</span><span class="n">partitioner</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="n">pcount</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">)</span>
                    <span class="o">.</span><span class="n">map_values</span><span class="p">(</span><span class="nb">list</span><span class="p">))</span></div>


<div class="viewcode-block" id="Dataset.group_by_key"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.group_by_key">[docs]</a>    <span class="k">def</span> <span class="nf">group_by_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">partitioner</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Group a K, V dataset by K.</span>

<span class="sd">        :param partitioner: callable</span>
<span class="sd">            The (optional) partitioner to apply.</span>
<span class="sd">        :param pcount:</span>
<span class="sd">            The number of partitions to group into.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">def</span> <span class="nf">strip_key</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">key</span><span class="p">,</span> <span class="n">pluck</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_by_key</span><span class="p">(</span><span class="n">partitioner</span><span class="p">,</span> <span class="n">pcount</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">)</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">strip_key</span><span class="p">)</span><span class="o">.</span><span class="n">map_values</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_group_by_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">partitioner</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">_group_by_key</span><span class="p">(</span><span class="n">partition</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">groupby</span><span class="p">(</span><span class="n">partition</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">getter</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">pcount</span><span class="p">,</span> <span class="n">partitioner</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">getter</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">)</span>
                    <span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="n">_group_by_key</span><span class="p">))</span>


<div class="viewcode-block" id="Dataset.aggregate_by_key"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.aggregate_by_key">[docs]</a>    <span class="k">def</span> <span class="nf">aggregate_by_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">local</span><span class="p">,</span> <span class="n">comb</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">partitioner</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Aggregate the values in a K, V1 dataset into a dataset of K, V2.</span>

<span class="sd">        :param local: callable(iterable[V1])</span>
<span class="sd">            A callable which returns the aggregation V2 for the values of a key.</span>
<span class="sd">        :param comb: callable(iterable[V2]): V2 (optional)</span>
<span class="sd">            A callable which performs a per key aggregation of the V2&#39;s</span>
<span class="sd">            generated by local. Defaults to local.</span>
<span class="sd">        :param partitioner:</span>
<span class="sd">            The (optional) partitioner to apply.</span>
<span class="sd">        :param pcount:</span>
<span class="sd">            The number of partitions to combine into.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">comb</span><span class="p">:</span>
            <span class="n">comb</span> <span class="o">=</span> <span class="n">local</span>

        <span class="k">def</span> <span class="nf">local_aggregation</span><span class="p">(</span><span class="n">partition</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="n">partition</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">getter</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
                <span class="k">yield</span> <span class="n">key</span><span class="p">,</span> <span class="n">local</span><span class="p">(</span><span class="n">pluck</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">group</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">merge_aggregations</span><span class="p">(</span><span class="n">partition</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="n">partition</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">getter</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
                <span class="k">yield</span> <span class="n">key</span><span class="p">,</span> <span class="n">comb</span><span class="p">(</span><span class="n">pluck</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">group</span><span class="p">))</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">pcount</span><span class="p">,</span> <span class="n">partitioner</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">getter</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                             <span class="n">comb</span><span class="o">=</span><span class="n">local_aggregation</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">)</span>
                    <span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="n">merge_aggregations</span><span class="p">))</span></div>


<div class="viewcode-block" id="Dataset.combine_by_key"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.combine_by_key">[docs]</a>    <span class="k">def</span> <span class="nf">combine_by_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">create</span><span class="p">,</span> <span class="n">merge_value</span><span class="p">,</span> <span class="n">merge_combs</span><span class="p">,</span>
                       <span class="n">partitioner</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Combine the values in a K, V1 dataset into a dataset of K, V2.</span>

<span class="sd">        :param create: callable(V1)</span>
<span class="sd">            A callable which returns the initial V2 for the value&#39;s key.</span>
<span class="sd">        :param merge_value: callable(V2, V1): V2</span>
<span class="sd">            A callable which merges a V1 into a V2.</span>
<span class="sd">        :param merge_combs: callable(V2, V2)</span>
<span class="sd">            A callable which merges two V2&#39;s.</span>
<span class="sd">        :param partitioner:</span>
<span class="sd">            The (optional) partitioner to apply.</span>
<span class="sd">        :param pcount:</span>
<span class="sd">            The number of partitions to combine into.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">def</span> <span class="nf">merge_values</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="n">create</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
                <span class="n">merged</span> <span class="o">=</span> <span class="n">merge_value</span><span class="p">(</span><span class="n">merged</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">merged</span>

        <span class="k">def</span> <span class="nf">merge_combined</span><span class="p">(</span><span class="n">combined</span><span class="p">):</span>
            <span class="n">combined</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">combined</span><span class="p">)</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">combined</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">combined</span><span class="p">:</span>
                <span class="n">merged</span> <span class="o">=</span> <span class="n">merge_combs</span><span class="p">(</span><span class="n">merged</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">merged</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate_by_key</span><span class="p">(</span><span class="n">merge_values</span><span class="p">,</span> <span class="n">merge_combined</span><span class="p">,</span> <span class="n">partitioner</span><span class="p">,</span>
                                     <span class="n">pcount</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.reduce_by_key"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.reduce_by_key">[docs]</a>    <span class="k">def</span> <span class="nf">reduce_by_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reduction</span><span class="p">,</span> <span class="n">partitioner</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Reduce the values of a K, V dataset.</span>

<span class="sd">        :param reduction: callable(v, v)</span>
<span class="sd">            The reduction to apply.</span>
<span class="sd">        :param partitioner:</span>
<span class="sd">            The (optional) partitioner to apply.</span>
<span class="sd">        :param pcount:</span>
<span class="sd">            The number of partitions to reduce into.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; ctx.range(12).map(lambda i: (i%3, 1)).reduce_by_key(lambda a, b: a+b).collect()</span>
<span class="sd">            [(0, 4), (1, 4), (2, 4)]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_by_key</span><span class="p">(</span><span class="n">identity</span><span class="p">,</span> <span class="n">reduction</span><span class="p">,</span> <span class="n">reduction</span><span class="p">,</span> <span class="n">partitioner</span><span class="p">,</span> <span class="n">pcount</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_cogroup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">*</span><span class="n">others</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">partitioner</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">key_or_getter</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="n">rdds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">rdd</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">((</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">+</span> <span class="n">others</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">rdds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rdd</span><span class="o">.</span><span class="n">map_values</span><span class="p">(</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">v</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rdds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rdd</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="n">idx</span><span class="p">:</span> <span class="p">((</span><span class="n">key</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">p</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">UnionDataset</span><span class="p">(</span><span class="n">rdds</span><span class="p">)</span><span class="o">.</span><span class="n">_group_by_key</span><span class="p">(</span><span class="n">partitioner</span><span class="p">,</span> <span class="n">pcount</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">cogroup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">*</span><span class="n">others</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">partitioner</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">):</span>
        <span class="n">num_rdds</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">others</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">local_cogroup</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">group</span> <span class="o">=</span> <span class="n">group</span>

            <span class="n">buckets</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_rdds</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">pluck</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">group</span><span class="p">):</span>
                <span class="n">buckets</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">key</span><span class="p">,</span> <span class="n">buckets</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cogroup</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="o">*</span><span class="n">others</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">partitioner</span><span class="o">=</span><span class="n">partitioner</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="n">pcount</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">)</span>
                    <span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">local_cogroup</span><span class="p">))</span>


<div class="viewcode-block" id="Dataset.join"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.join">[docs]</a>    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">partitioner</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Join two datasets.</span>

<span class="sd">        :param other:</span>
<span class="sd">            The dataset to join with.</span>
<span class="sd">        :param key: callable(element) or object</span>
<span class="sd">            The callable which returns the join key or an object used as index</span>
<span class="sd">            to get the join key from the elements in the datasets to join.</span>
<span class="sd">        :param partitioner:</span>
<span class="sd">            The (optional) partitioner to apply.</span>
<span class="sd">        :param pcount:</span>
<span class="sd">            The number of partitions to join into.</span>

<span class="sd">        Example::</span>

<span class="sd">            &gt;&gt;&gt; ctx.range(0, 5).key_by(lambda i: i%2).join(ctx.range(5, 10).key_by(lambda i: i%2)).collect()</span>
<span class="sd">            [(0, [(0, 8), (0, 6), (2, 8), (2, 6), (4, 8), (4, 6)]),</span>
<span class="sd">             (1, [(1, 5), (1, 9), (1, 7), (3, 5), (3, 9), (3, 7)])]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">def</span> <span class="nf">local_join</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">groups</span> <span class="o">=</span> <span class="n">group</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">groups</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">key</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">groups</span><span class="p">))</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cogroup</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">partitioner</span><span class="o">=</span><span class="n">partitioner</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="n">pcount</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">)</span>
                    <span class="o">.</span><span class="n">flatmap</span><span class="p">(</span><span class="n">local_join</span><span class="p">))</span></div>


    <span class="k">def</span> <span class="nf">product</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">*</span><span class="n">others</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CartesianProductDataset</span><span class="p">((</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">+</span> <span class="n">others</span><span class="p">)</span>


<div class="viewcode-block" id="Dataset.distinct"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.distinct">[docs]</a>    <span class="k">def</span> <span class="nf">distinct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Select the distinct elements from this dataset.</span>

<span class="sd">        :param pcount:</span>
<span class="sd">            The number of partitions to shuffle into.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; sorted(ctx.range(10).map(lambda i: i%2).distinct().collect())</span>
<span class="sd">            [0, 1]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">key_or_getter</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">.shuffle</span> <span class="k">import</span> <span class="n">DictBucket</span>
            <span class="n">bucket</span> <span class="o">=</span> <span class="n">DictBucket</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">.shuffle</span> <span class="k">import</span> <span class="n">SetBucket</span>
            <span class="n">bucket</span> <span class="o">=</span> <span class="n">SetBucket</span>

        <span class="n">shuffle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">pcount</span><span class="p">,</span> <span class="n">bucket</span><span class="o">=</span><span class="n">bucket</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">comb</span><span class="o">=</span><span class="nb">sorted</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">select_distinct</span><span class="p">(</span><span class="n">partition</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="n">partition</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">):</span>
                <span class="k">yield</span> <span class="nb">next</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">shuffle</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="n">select_distinct</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.count_distinct"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.count_distinct">[docs]</a>    <span class="k">def</span> <span class="nf">count_distinct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Count the distinct elements in this Dataset.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">distinct</span><span class="p">(</span><span class="n">pcount</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">()</span></div>


<div class="viewcode-block" id="Dataset.count_distinct_approx"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.count_distinct_approx">[docs]</a>    <span class="k">def</span> <span class="nf">count_distinct_approx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error_rate</span><span class="o">=.</span><span class="mi">05</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Approximate the count of distinct elements in this Dataset through</span>
<span class="sd">        the hyperloglog++ algorithm based on https://github.com/svpcom/hyperloglog.</span>

<span class="sd">        :param error_rate: float</span>
<span class="sd">            The absolute error / cardinality</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">_as_bytes</span><span class="p">)</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">HyperLogLog</span><span class="p">(</span><span class="n">error_rate</span><span class="p">)</span><span class="o">.</span><span class="n">add_all</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
            <span class="k">lambda</span> <span class="n">hlls</span><span class="p">:</span> <span class="n">HyperLogLog</span><span class="p">(</span><span class="n">error_rate</span><span class="p">)</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="o">*</span><span class="n">hlls</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">card</span><span class="p">()</span></div>


<div class="viewcode-block" id="Dataset.count_by_value"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.count_by_value">[docs]</a>    <span class="k">def</span> <span class="nf">count_by_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Count the occurrence of each distinct value in the data set.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_aggregate</span><span class="p">(</span><span class="n">Counter</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">counters</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="n">counters</span><span class="p">,</span> <span class="n">Counter</span><span class="p">()),</span>
                                   <span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">)</span></div>



<div class="viewcode-block" id="Dataset.sort"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.sort">[docs]</a>    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hd_distribution</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sort the elements in this dataset.</span>

<span class="sd">        :param key: callable or obj</span>
<span class="sd">            A callable which returns the sort key or an object which is the</span>
<span class="sd">            index in the elements for getting the sort key.</span>
<span class="sd">        :param reverse: bool</span>
<span class="sd">            If True perform a sort in descending order, or False to sort in</span>
<span class="sd">            ascending order.</span>
<span class="sd">        :param pcount:</span>
<span class="sd">            Optionally the number of partitions to sort into.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; &#39;&#39;.join(ctx.collection(&#39;asdfzxcvqwer&#39;).sort().collect())</span>
<span class="sd">            &#39;acdefqrsvwxz&#39;</span>

<span class="sd">            &gt;&gt;&gt; ctx.range(5).map(lambda i: dict(a=i-2, b=i)).sort(key=&#39;a&#39;).collect()</span>
<span class="sd">            [{&#39;b&#39;: 0, &#39;a&#39;: -2}, {&#39;b&#39;: 1, &#39;a&#39;: -1}, {&#39;b&#39;: 2, &#39;a&#39;: 0}, {&#39;b&#39;: 3, &#39;a&#39;: 1}, {&#39;b&#39;: 4, &#39;a&#39;: 2}]</span>

<span class="sd">            &gt;&gt;&gt; ctx.range(5).key_by(lambda i: i-2).sort(key=1).sort().collect()</span>
<span class="sd">            [(-2, 0), (-1, 1), (0, 2), (1, 3), (2, 4)]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">bndl.compute.shuffle</span> <span class="k">import</span> <span class="n">RangePartitioner</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">key_or_getter</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pcount</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pcount</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">pcount</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">pcount</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">)</span>

        <span class="n">point_count</span> <span class="o">=</span> <span class="n">pcount</span> <span class="o">*</span> <span class="mi">20</span>

        <span class="k">if</span> <span class="n">hd_distribution</span><span class="p">:</span>
            <span class="n">dset_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">dset_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>
            <span class="c1"># sample to find a good distribution over buckets</span>
            <span class="n">fraction</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">pcount</span> <span class="o">*</span> <span class="mf">20.</span> <span class="o">/</span> <span class="n">dset_size</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">fraction</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">()</span>
            <span class="k">def</span> <span class="nf">sampler</span><span class="p">(</span><span class="n">partition</span><span class="p">):</span>
                <span class="n">fraction</span> <span class="o">=</span> <span class="mf">0.1</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">partition</span><span class="p">,</span> <span class="n">Sized</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">partition</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">point_count</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">partition</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">fraction</span> <span class="o">=</span> <span class="n">point_count</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">partition</span><span class="p">)</span>
                        <span class="n">samples</span> <span class="o">=</span> <span class="n">sample_without_replacement</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="n">fraction</span><span class="p">,</span> <span class="n">partition</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">samples1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">partition</span><span class="p">,</span> <span class="n">point_count</span><span class="p">))</span>
                    <span class="n">samples2</span> <span class="o">=</span> <span class="n">sample_without_replacement</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="n">fraction</span><span class="p">,</span> <span class="n">partition</span><span class="p">)</span>
                    <span class="n">short</span> <span class="o">=</span> <span class="n">point_count</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">short</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">short</span><span class="p">:</span>
                            <span class="n">samples</span> <span class="o">=</span> <span class="n">samples1</span> <span class="o">+</span> <span class="n">samples2</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">rng</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">samples1</span><span class="p">)</span>
                            <span class="n">samples</span> <span class="o">=</span> <span class="n">samples1</span><span class="p">[:</span><span class="n">short</span><span class="p">]</span> <span class="o">+</span> <span class="n">samples2</span>
                    <span class="k">elif</span> <span class="n">short</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">rng</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">samples1</span><span class="p">)</span>
                        <span class="n">samples</span> <span class="o">=</span> <span class="n">samples1</span><span class="p">[:</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">samples1</span><span class="p">)</span> <span class="o">*</span> <span class="n">fraction</span><span class="p">)]</span> <span class="o">+</span> <span class="n">samples2</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">point_count</span><span class="p">:</span>
                    <span class="n">rng</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">samples</span><span class="p">[:</span><span class="n">point_count</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">samples</span>
            <span class="k">with</span> <span class="n">set_callsite</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;sort.sampler&#39;</span><span class="p">):</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="n">sampler</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>

        <span class="k">assert</span> <span class="n">samples</span>

        <span class="c1"># apply the key function if any</span>
        <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">samples</span><span class="p">))</span>
        <span class="c1"># sort the samples to function as boundaries</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>
        <span class="c1"># take pcount - 1 points evenly spaced from the samples as boundaries</span>
        <span class="n">boundaries</span> <span class="o">=</span> <span class="p">[</span><span class="n">samples</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">pcount</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pcount</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="c1"># and use that in the range partitioner to shuffle</span>
        <span class="n">partitioner</span> <span class="o">=</span> <span class="n">RangePartitioner</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span> <span class="n">reverse</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">pcount</span><span class="p">,</span> <span class="n">partitioner</span><span class="o">=</span><span class="n">partitioner</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="o">**</span><span class="n">shuffle_opts</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.shuffle"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.shuffle">[docs]</a>    <span class="k">def</span> <span class="nf">shuffle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pcount</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">partitioner</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bucket</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">comb</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. todo::</span>

<span class="sd">            Document shuffle</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">key_or_getter</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">.shuffle</span> <span class="k">import</span> <span class="n">ShuffleReadingDataset</span><span class="p">,</span> <span class="n">ShuffleWritingDataset</span><span class="p">,</span> <span class="n">ListBucket</span>
        <span class="k">if</span> <span class="n">bucket</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">sort</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">bucket</span> <span class="o">=</span> <span class="n">ListBucket</span>
        <span class="n">shuffle</span> <span class="o">=</span> <span class="n">ShuffleWritingDataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pcount</span><span class="p">,</span> <span class="n">partitioner</span><span class="p">,</span> <span class="n">bucket</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">comb</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ShuffleReadingDataset</span><span class="p">(</span><span class="n">shuffle</span><span class="p">,</span> <span class="n">sort</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.zip"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.zip">[docs]</a>    <span class="k">def</span> <span class="nf">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Zip the elements of another data set with the elements of this data set.</span>

<span class="sd">        :param other: bndl.compute.dataset.Dataset</span>
<span class="sd">            The other data set to zip with.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; ctx.range(0,10).zip(ctx.range(10,20)).collect()</span>
<span class="sd">            [(0, 10), (1, 11), (2, 12), (3, 13), (4, 14), (5, 15), (6, 16), (7, 17), (8, 18), (9, 19)]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># TODO what if some partition is shorter/longer than another?</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">zip_partitions</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">zip</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.zip_partitions"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.zip_partitions">[docs]</a>    <span class="k">def</span> <span class="nf">zip_partitions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">comb</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Zip the partitions of another data set with the partitions of this data set.</span>

<span class="sd">        :param other: bndl.compute.dataset.Dataset</span>
<span class="sd">            The other data set to zip the partitions of with the partitions of this data set.</span>
<span class="sd">        :param comb: func(iterable, iterable)</span>
<span class="sd">            The function which combines the data of the partitions from this</span>
<span class="sd">            and the other data sets.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; ctx.range(0,10).zip_partitions(ctx.range(10,20), lambda a, b: zip(a,b)).collect()</span>
<span class="sd">            [(0, 10), (1, 11), (2, 12), (3, 13), (4, 14), (5, 15), (6, 16), (7, 17), (8, 18), (9, 19)]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">.zip</span> <span class="k">import</span> <span class="n">ZippedDataset</span>
        <span class="k">return</span> <span class="n">ZippedDataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">comb</span><span class="o">=</span><span class="n">comb</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.sample"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fraction</span><span class="p">,</span> <span class="n">with_replacement</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. todo::</span>

<span class="sd">            Document sample</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">fraction</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">fraction</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">fraction</span> <span class="o">&lt;</span> <span class="mi">1</span>

        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="n">sampling</span> <span class="o">=</span> <span class="n">sample_with_replacement</span> <span class="k">if</span> <span class="n">with_replacement</span> <span class="k">else</span> <span class="n">sample_without_replacement</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">sampling</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">fraction</span><span class="p">))</span></div>


    <span class="c1"># TODO implement stratified sampling</span>

<div class="viewcode-block" id="Dataset.take_sample"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.take_sample">[docs]</a>    <span class="k">def</span> <span class="nf">take_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">with_replacement</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        based on https://github.com/apache/spark/blob/master/python/pyspark/rdd.py#L425</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">num</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">count</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">with_replacement</span><span class="p">)</span> <span class="ow">and</span> <span class="n">num</span> <span class="o">&gt;=</span> <span class="n">count</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
            <span class="n">rng</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">samples</span>

        <span class="n">fraction</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">/</span> <span class="n">count</span>
        <span class="k">if</span> <span class="n">with_replacement</span><span class="p">:</span>
            <span class="n">num_stdev</span> <span class="o">=</span> <span class="mi">9</span> <span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&lt;</span> <span class="mi">12</span><span class="p">)</span> <span class="k">else</span> <span class="mi">5</span>
            <span class="n">fraction</span> <span class="o">=</span> <span class="n">fraction</span> <span class="o">+</span> <span class="n">num_stdev</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">fraction</span> <span class="o">/</span> <span class="n">count</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="mf">0.00005</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="o">-</span><span class="n">log</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span> <span class="o">/</span> <span class="n">count</span>
            <span class="n">fraction</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">fraction</span> <span class="o">+</span> <span class="n">gamma</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">fraction</span><span class="p">))</span>

        <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">fraction</span><span class="p">,</span> <span class="n">with_replacement</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">:</span>
            <span class="n">seed</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">fraction</span><span class="p">,</span> <span class="n">with_replacement</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>

        <span class="n">rng</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">num</span><span class="p">]</span></div>



<div class="viewcode-block" id="Dataset.collect"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.collect">[docs]</a>    <span class="k">def</span> <span class="nf">collect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ordered</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Collect the dataset as list.</span>

<span class="sd">        Args:</span>
<span class="sd">            parts (bool): Collect the individual partitions (``True``) into a list with an element</span>
<span class="sd">                per partition or a &#39;flattened&#39; list of the elements in the dataset (``False``).</span>
<span class="sd">            ordered (bool): Collect partitions (and thus their elements) in order or not.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">icollect</span><span class="p">(</span><span class="n">parts</span><span class="p">,</span> <span class="n">ordered</span><span class="p">))</span></div>


<div class="viewcode-block" id="Dataset.collect_as_map"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.collect_as_map">[docs]</a>    <span class="k">def</span> <span class="nf">collect_as_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parts</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Collect a dataset of key-value pairs as dict.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">dicts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">parts</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dicts</span><span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">combined</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dicts</span><span class="o">.</span><span class="n">icollect</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">combined</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">combined</span></div>


<div class="viewcode-block" id="Dataset.collect_as_set"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.collect_as_set">[docs]</a>    <span class="k">def</span> <span class="nf">collect_as_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Collect the elements of the dataset into a set.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span><span class="o">.</span><span class="n">icollect</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">s</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span></div>


<div class="viewcode-block" id="Dataset.collect_as_pickles"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.collect_as_pickles">[docs]</a>    <span class="k">def</span> <span class="nf">collect_as_pickles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Collect each partition as a pickle file into directory</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">glom</span><span class="p">()</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">)</span><span class="o">.</span><span class="n">collect_as_files</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="s1">&#39;.p&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">compress</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.collect_as_json"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.collect_as_json">[docs]</a>    <span class="k">def</span> <span class="nf">collect_as_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Collect each partition as a line separated json file into directory.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">)</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="p">)</span><span class="o">.</span><span class="n">collect_as_files</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="s1">&#39;.json&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="n">compress</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.collect_as_files"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.collect_as_files">[docs]</a>    <span class="k">def</span> <span class="nf">collect_as_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Collect each element in this data set into a file into directory.</span>

<span class="sd">        :param directory: str</span>
<span class="sd">            The directory to save this data set to.</span>
<span class="sd">        :param ext:</span>
<span class="sd">            The extenion of the files.</span>
<span class="sd">        :param compress: None or &#39;gzip&#39;</span>
<span class="sd">            Whether to compress.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">directory</span><span class="p">:</span>
            <span class="n">directory</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;mode should be t(ext) or b(inary)&#39;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="c1"># compress if necessary</span>
        <span class="k">if</span> <span class="n">compress</span> <span class="o">==</span> <span class="s1">&#39;gzip&#39;</span><span class="p">:</span>
            <span class="n">ext</span> <span class="o">+=</span> <span class="s1">&#39;.gz&#39;</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
            <span class="c1"># compress concatenation of partition, not just each element</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;b&#39;</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">b</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">gzip</span><span class="o">.</span><span class="n">compress</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">compress</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Only gzip compression is supported&#39;</span><span class="p">)</span>
        <span class="c1"># add an index to the partitions (for in the filename)</span>
        <span class="n">with_idx</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">map_partitions_with_index</span><span class="p">(</span><span class="k">lambda</span> <span class="n">idx</span><span class="p">,</span> <span class="n">part</span><span class="p">:</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">ensure_collection</span><span class="p">(</span><span class="n">part</span><span class="p">)))</span>
        <span class="c1"># save each partition to a file</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">with_idx</span><span class="o">.</span><span class="n">icollect</span><span class="p">(</span><span class="n">ordered</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parts</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%s%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">ext</span><span class="p">)),</span> <span class="s1">&#39;w&#39;</span> <span class="o">+</span> <span class="n">mode</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">part</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">consume_iterable</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_stable_iterable</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="n">consume_iterable</span><span class="p">)</span><span class="o">.</span><span class="n">_execute</span><span class="p">(</span><span class="n">ordered</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">pass</span>


<div class="viewcode-block" id="Dataset.icollect"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.icollect">[docs]</a>    <span class="k">def</span> <span class="nf">icollect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ordered</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        An iterable version of :meth:`collect` which can be cheaper memory-wise and faster in terms</span>
<span class="sd">        of latency (especially of ordered=False).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execute</span><span class="p">(</span><span class="n">ordered</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>  <span class="c1"># filter out empty parts</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">parts</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># chain the parts into a big iterable</span>
        <span class="k">yield from</span> <span class="n">result</span></div>


<div class="viewcode-block" id="Dataset.first"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.first">[docs]</a>    <span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Take the first element from this dataset.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">taker</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">itake</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">first</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">taker</span><span class="p">)</span>
        <span class="n">taker</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">first</span></div>


<div class="viewcode-block" id="Dataset.take"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.take">[docs]</a>    <span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Take the first num elements from this dataset.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">itake</span><span class="p">(</span><span class="n">num</span><span class="p">))</span></div>


<div class="viewcode-block" id="Dataset.itake"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.itake">[docs]</a>    <span class="k">def</span> <span class="nf">itake</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Take the first num elements from this dataset as iterator.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">running</span><span class="p">,</span> <span class="s1">&#39;context of dataset is not running&#39;</span>
        <span class="n">remaining</span> <span class="o">=</span> <span class="n">num</span>
        <span class="n">sliced</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_partitions</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">take</span><span class="p">,</span> <span class="n">remaining</span><span class="p">))</span><span class="o">.</span><span class="n">_itake_parts</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">sliced</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">part</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">islice</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">remaining</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">e</span>
                    <span class="n">remaining</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">remaining</span><span class="p">:</span>
                    <span class="k">break</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">sliced</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">_itake_parts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">pcount</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">())</span>
        <span class="k">while</span> <span class="n">mask</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">pcount</span><span class="p">:</span>
            <span class="n">masked</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_partitions</span><span class="p">(</span><span class="k">lambda</span> <span class="n">parts</span><span class="p">:</span> <span class="n">parts</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
            <span class="n">done</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">masked</span><span class="o">.</span><span class="n">_schedule</span><span class="p">())</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">done</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">mask</span><span class="o">.</span><span class="n">stop</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">done</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<div class="viewcode-block" id="Dataset.require_workers"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.require_workers">[docs]</a>    <span class="k">def</span> <span class="nf">require_workers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">workers_required</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Create a clone of this dataset which is only computable on the workers</span>
<span class="sd">        which are returned by the workers_required argument.</span>

<span class="sd">        :param workers_required: function(iterable[PeerNode]): -&gt; iterable[PeerNode]</span>
<span class="sd">            A function which is given an iterable of workers (PeerNodes) which is to</span>
<span class="sd">            return only those which are allowed to compute this dataset.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_with</span><span class="p">(</span><span class="n">_workers_required</span><span class="o">=</span><span class="n">workers_required</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.require_local_workers"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.require_local_workers">[docs]</a>    <span class="k">def</span> <span class="nf">require_local_workers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Require that the dataset is computed on the same node as the driver.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">require_workers</span><span class="p">(</span><span class="k">lambda</span> <span class="n">workers</span><span class="p">:</span> <span class="p">[</span><span class="n">worker</span><span class="o">.</span><span class="n">islocal</span><span class="p">()</span> <span class="k">for</span> <span class="n">worker</span> <span class="ow">in</span> <span class="n">workers</span><span class="p">])</span></div>


<div class="viewcode-block" id="Dataset.allow_all_workers"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.allow_all_workers">[docs]</a>    <span class="k">def</span> <span class="nf">allow_all_workers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Create a clone of this dataset which resets the worker filter set by</span>
<span class="sd">        require_workers if any.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_workers_required</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_with</span><span class="p">(</span><span class="n">_workers_required</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span></div>


    <span class="k">def</span> <span class="nf">_execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ordered</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">running</span><span class="p">,</span> <span class="s1">&#39;context of dataset is not running&#39;</span>
        <span class="n">job</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_schedule</span><span class="p">()</span>
        <span class="n">done</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">job</span><span class="p">,</span> <span class="n">order_results</span><span class="o">=</span><span class="n">ordered</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">done</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">_generate_tasks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tasks</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">groups</span><span class="p">):</span>
        <span class="n">dset_tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">ComputePartitionTask</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="n">group</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">()]</span>

        <span class="n">stack</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="n">src</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">src</span>
        <span class="k">if</span> <span class="n">src</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">sync_required</span><span class="p">:</span>
                <span class="n">cached</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">cached</span> <span class="ow">and</span> <span class="n">d</span><span class="o">.</span><span class="n">_cache_locs</span>
                <span class="n">groups</span><span class="p">,</span> <span class="n">dependencies</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">_generate_tasks</span><span class="p">(</span><span class="n">tasks</span><span class="p">,</span> <span class="n">group</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span> <span class="n">group</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">barrier</span> <span class="o">=</span> <span class="n">BarrierTask</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dependencies</span><span class="p">)),</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;hidden&#39;</span><span class="p">)</span>
                <span class="n">tasks</span><span class="p">[</span><span class="n">barrier</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">barrier</span>
                <span class="n">barrier</span><span class="o">.</span><span class="n">dependents</span> <span class="o">=</span> <span class="n">dset_tasks</span>
                <span class="n">barrier</span><span class="o">.</span><span class="n">dependencies</span> <span class="o">=</span> <span class="n">dependencies</span>
                <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">dset_tasks</span><span class="p">:</span>
                    <span class="n">task</span><span class="o">.</span><span class="n">dependencies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">barrier</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">dependency</span> <span class="ow">in</span> <span class="n">dependencies</span><span class="p">:</span>
                    <span class="n">dependency</span><span class="o">.</span><span class="n">dependents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">barrier</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">cached</span><span class="p">:</span>
                        <span class="n">dependency</span><span class="o">.</span><span class="n">mark_done</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">d_src</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">src</span>
                <span class="k">if</span> <span class="n">d_src</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d_src</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                        <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">d_src</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d_src</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">dset_tasks</span><span class="p">:</span>
            <span class="n">tasks</span><span class="p">[</span><span class="n">task</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">task</span>

        <span class="k">return</span> <span class="n">groups</span><span class="p">,</span> <span class="n">dset_tasks</span>


    <span class="k">def</span> <span class="nf">_schedule</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">tasks</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">groups</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_tasks</span><span class="p">(</span><span class="n">tasks</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">taskslist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">priority</span><span class="p">,</span> <span class="n">task</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tasks</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">group</span> <span class="o">!=</span> <span class="s1">&#39;hidden&#39;</span><span class="p">:</span>
                <span class="n">task</span><span class="o">.</span><span class="n">group</span> <span class="o">=</span> <span class="n">groups</span> <span class="o">-</span> <span class="n">task</span><span class="o">.</span><span class="n">group</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">task</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">priority</span>
            <span class="n">taskslist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
        <span class="n">tasks</span> <span class="o">=</span> <span class="n">taskslist</span>

        <span class="n">name</span><span class="p">,</span> <span class="n">desc</span> <span class="o">=</span> <span class="n">get_callsite</span><span class="p">(</span><span class="n">__file__</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;[_.]&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">name</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">job</span> <span class="o">=</span> <span class="n">Job</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">tasks</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">desc</span><span class="p">)</span>

        <span class="n">cleanups</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">dset</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">dset</span><span class="o">.</span><span class="n">cleanup</span><span class="p">:</span>
                <span class="n">cleanups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dset</span><span class="o">.</span><span class="n">cleanup</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dset</span><span class="o">.</span><span class="n">src</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">dset</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">dset</span><span class="o">.</span><span class="n">src</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dset</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cleanups</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">cleanup</span><span class="p">(</span><span class="n">job</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">job</span><span class="o">.</span><span class="n">stopped</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">cleanup</span> <span class="ow">in</span> <span class="n">cleanups</span><span class="p">:</span>
                        <span class="n">cleanup</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
            <span class="n">job</span><span class="o">.</span><span class="n">add_listener</span><span class="p">(</span><span class="n">cleanup</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">job</span>


<div class="viewcode-block" id="Dataset.cache"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Dataset.cache">[docs]</a>    <span class="k">def</span> <span class="nf">cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="s1">&#39;memory&#39;</span><span class="p">,</span> <span class="n">serialization</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">provider</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Cache the dataset in the workers. Each partition is cached in the memory / on the disk of</span>
<span class="sd">        the worker which computed it.</span>

<span class="sd">        Args:</span>
<span class="sd">            location (str): &#39;memory&#39; or &#39;disk&#39;.</span>
<span class="sd">            serialization (str): The serialization format must be one of &#39;json&#39;, &#39;marshal&#39;,</span>
<span class="sd">                &#39;pickle&#39;, &#39;msgpack&#39;, &#39;text&#39;, &#39;binary&#39; or None to cache the data unserialized.</span>
<span class="sd">            compression (str): &#39;gzip&#39; or None</span>
<span class="sd">            provider (:class:`CacheProvider &lt;bndl.compute.cache.CacheProvider&gt;`): Ignore location,</span>
<span class="sd">                serialization and compression and use this custom ``CacheProvider``.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">node_type</span> <span class="o">==</span> <span class="s1">&#39;driver&#39;</span>
        <span class="k">if</span> <span class="n">location</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">location</span> <span class="o">==</span> <span class="s1">&#39;disk&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">serialization</span><span class="p">:</span>
                <span class="n">serialization</span> <span class="o">=</span> <span class="s1">&#39;pickle&#39;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache_provider</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cache_provider</span><span class="o">.</span><span class="n">modify</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">serialization</span><span class="p">,</span> <span class="n">compression</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cache_provider</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">CacheProvider</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">serialization</span><span class="p">,</span> <span class="n">compression</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">uncache</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cached</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cache_provider</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">uncache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">cached</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Uncaching </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="c1"># issue uncache tasks</span>
        <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="n">provider</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cache_provider</span><span class="p">,</span> <span class="n">dset_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">):</span>
            <span class="n">provider</span><span class="o">.</span><span class="n">clear</span><span class="p">(</span><span class="n">dset_id</span><span class="p">)</span>

        <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">worker</span><span class="o">.</span><span class="n">execute</span> <span class="k">for</span> <span class="n">worker</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">workers</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">timeout</span><span class="p">:</span>
            <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">task</span><span class="o">.</span><span class="n">with_timeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">tasks</span><span class="p">]</span>
        <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">task</span><span class="p">(</span><span class="n">clear</span><span class="p">)</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">tasks</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">block</span><span class="p">:</span>
            <span class="c1"># wait for them to finish</span>
            <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">tasks</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
                <span class="k">except</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">TimeoutError</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Error while uncaching </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># clear cache locations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache_locs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache_provider</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="bp">self</span>


    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_cache_provider&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">with</span> <span class="n">catch</span><span class="p">(</span><span class="ne">RuntimeError</span><span class="p">):</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">node</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">node_type</span> <span class="o">==</span> <span class="s1">&#39;driver&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">uncache</span><span class="p">()</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s1">&#39;Unable to clear cache&#39;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">id</span>


    <span class="k">def</span> <span class="nf">_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">clone</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">clone</span><span class="o">.</span><span class="n">__dict__</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">attribute</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">clone</span><span class="p">,</span> <span class="n">attribute</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="n">clone</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">clone</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">strings</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">clone</span>


    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">state</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>
        <span class="n">state</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;callsite&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">state</span>


    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;</span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1">&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">callsite</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;callsite&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">callsite</span> <span class="ow">and</span> <span class="n">callsite</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">callsite</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span></div>


<span class="n">FORBIDDEN</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="n">NON_LOCAL</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">LOCAL</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">NODE_LOCAL</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">PROCESS_LOCAL</span> <span class="o">=</span> <span class="mi">5</span>


<span class="nd">@total_ordering</span>
<div class="viewcode-block" id="Partition"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Partition">[docs]</a><span class="k">class</span> <span class="nc">Partition</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dset</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dset</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="n">dset</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">src</span> <span class="o">=</span> <span class="n">src</span>


    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">cached</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dset</span><span class="o">.</span><span class="n">cached</span>
        <span class="n">cache_loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_loc</span><span class="p">()</span>

        <span class="c1"># check cache</span>
        <span class="k">if</span> <span class="n">cached</span> <span class="ow">and</span> <span class="n">cache_loc</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cache_loc</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dset</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Using local cache for </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dset</span><span class="o">.</span><span class="n">_cache_provider</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dset</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Using remote cache for </span><span class="si">%r</span><span class="s1"> on </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">cache_loc</span><span class="p">)</span>
                    <span class="n">peer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dset</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">peers</span><span class="p">[</span><span class="n">cache_loc</span><span class="p">]</span>
                    <span class="k">return</span> <span class="n">peer</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dset</span><span class="o">.</span><span class="n">_cache_provider</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dset</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">))</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">except</span> <span class="n">NotConnected</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Unable to get cached partition </span><span class="si">%s</span><span class="s1">.</span><span class="si">%s</span><span class="s1"> from </span><span class="si">%s</span><span class="s1"> (not connected)&#39;</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">dset</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">,</span> <span class="n">cache_loc</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">InvocationException</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="n">exc</span> <span class="o">=</span> <span class="n">root_exc</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Unable to get cached partition </span><span class="si">%s</span><span class="s1">.</span><span class="si">%s</span><span class="s1"> from </span><span class="si">%s</span><span class="s1"> (not found)&#39;</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">dset</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">,</span> <span class="n">cache_loc</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Unable to get cached partition </span><span class="si">%s</span><span class="s1">.</span><span class="si">%s</span><span class="s1"> from </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">dset</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">,</span> <span class="n">cache_loc</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Unable to get cached partition </span><span class="si">%s</span><span class="s1">.</span><span class="si">%s</span><span class="s1"> from </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">dset</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">,</span> <span class="n">cache_loc</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># compute if not cached</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Computing </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute</span><span class="p">()</span>

        <span class="c1"># cache if requested</span>
        <span class="k">if</span> <span class="n">cached</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Caching </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">ensure_collection</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dset</span><span class="o">.</span><span class="n">_cache_provider</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dset</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

        <span class="c1"># return data</span>
        <span class="k">return</span> <span class="n">data</span>


    <span class="k">def</span> <span class="nf">cache_loc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dset</span><span class="o">.</span><span class="n">_cache_locs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> does not implement _compute&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>


<div class="viewcode-block" id="Partition.locality"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.Partition.locality">[docs]</a>    <span class="k">def</span> <span class="nf">locality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">workers</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Determine locality of computing this partition at the given workers.</span>

<span class="sd">        :return: a generator of worker, locality pairs.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dset</span><span class="o">.</span><span class="n">_workers_required</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">allowed</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dset</span><span class="o">.</span><span class="n">_workers_required</span><span class="p">(</span><span class="n">workers</span><span class="p">))</span>
            <span class="n">forbidden</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">workers</span><span class="p">)</span> <span class="o">-</span> <span class="n">allowed</span>
            <span class="n">workers</span> <span class="o">=</span> <span class="n">allowed</span>
            <span class="k">for</span> <span class="n">worker</span> <span class="ow">in</span> <span class="n">forbidden</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">worker</span><span class="p">,</span> <span class="n">FORBIDDEN</span>

        <span class="n">cache_loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_loc</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">cache_loc</span><span class="p">:</span>
            <span class="n">workers_filtered</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">workers</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">worker</span> <span class="ow">in</span> <span class="n">workers</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cache_loc</span> <span class="o">==</span> <span class="n">worker</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">worker</span><span class="p">,</span> <span class="n">PROCESS_LOCAL</span>
                    <span class="n">workers_filtered</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">worker</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">worker</span><span class="o">.</span><span class="n">islocal</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">worker</span><span class="p">,</span> <span class="n">NODE_LOCAL</span>
                    <span class="n">workers_filtered</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">worker</span><span class="p">)</span>
            <span class="n">workers</span> <span class="o">=</span> <span class="n">workers_filtered</span>

        <span class="k">if</span> <span class="n">workers</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locality</span><span class="p">(</span><span class="n">workers</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_locality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">workers</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Determine locality of computing this partition. Cache locality is dealt</span>
<span class="sd">        with when this method is invoked by Partition.locality(workers).</span>

<span class="sd">        Typically source partition implementations which inherit from Partition</span>
<span class="sd">        indicate here whether computing on a worker shows locality. This allows</span>
<span class="sd">        dealing with caching and preference/requirements set at the data set</span>
<span class="sd">        separately from locality in the &#39;normal&#39; case.</span>

<span class="sd">        :param workers: An iterable of workers.</span>
<span class="sd">        :returns: An iterable of (worker, locality:int) tuples indicating the</span>
<span class="sd">        worker locality; locality 0 can be omitted as this is the default</span>
<span class="sd">        locality.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                <span class="n">localities</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">forbidden</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">src</span><span class="o">.</span><span class="n">dset</span><span class="o">.</span><span class="n">sync_required</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="k">for</span> <span class="n">worker</span><span class="p">,</span> <span class="n">locality</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">locality</span><span class="p">(</span><span class="n">workers</span><span class="p">)</span> <span class="ow">or</span> <span class="p">():</span>
                        <span class="k">if</span> <span class="n">locality</span> <span class="o">==</span> <span class="n">FORBIDDEN</span><span class="p">:</span>
                            <span class="n">forbidden</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">worker</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">localities</span><span class="p">[</span><span class="n">worker</span><span class="p">]</span> <span class="o">+=</span> <span class="n">locality</span>
                <span class="k">for</span> <span class="n">worker</span> <span class="ow">in</span> <span class="n">forbidden</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">worker</span><span class="p">,</span> <span class="n">FORBIDDEN</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">localities</span><span class="p">[</span><span class="n">worker</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">pass</span>
                <span class="n">src_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">worker</span><span class="p">,</span> <span class="n">locality</span> <span class="ow">in</span> <span class="n">localities</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">yield</span> <span class="n">worker</span><span class="p">,</span> <span class="n">locality</span> <span class="o">/</span> <span class="n">src_count</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">src</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">src</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">src</span><span class="o">.</span><span class="n">dset</span><span class="o">.</span><span class="n">sync_required</span><span class="p">:</span>
                    <span class="k">yield from</span> <span class="n">src</span><span class="o">.</span><span class="n">locality</span><span class="p">(</span><span class="n">workers</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">save_cache_location</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dset</span>
            <span class="n">dset</span><span class="o">.</span><span class="n">id</span>
        <span class="k">except</span> <span class="ne">ReferenceError</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># memorize the cache location for the partition</span>
        <span class="k">if</span> <span class="n">dset</span><span class="o">.</span><span class="n">cached</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dset</span><span class="o">.</span><span class="n">_cache_locs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">):</span>
            <span class="n">dset</span><span class="o">.</span><span class="n">_cache_locs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">worker</span>
        <span class="c1"># traverse backup up the task (not the entire DAG)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">src</span><span class="o">.</span><span class="n">dset</span><span class="o">.</span><span class="n">sync_required</span><span class="p">:</span>
                        <span class="n">src</span><span class="o">.</span><span class="n">save_cache_location</span><span class="p">(</span><span class="n">worker</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">src</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">src</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">src</span><span class="o">.</span><span class="n">dset</span><span class="o">.</span><span class="n">sync_required</span><span class="p">:</span>
                    <span class="n">src</span><span class="o">.</span><span class="n">save_cache_location</span><span class="p">(</span><span class="n">worker</span><span class="p">)</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dset</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">id</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">id</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;</span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1">.</span><span class="si">%s</span><span class="s1">&gt;&#39;</span> <span class="o">%</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span></div>



<span class="k">class</span> <span class="nc">MaskedDataset</span><span class="p">(</span><span class="n">Dataset</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span>


    <span class="k">def</span> <span class="nf">parts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="o">.</span><span class="n">parts</span><span class="p">())</span>



<span class="k">def</span> <span class="nf">_merge_multisource</span><span class="p">(</span><span class="n">others</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span>
    <span class="n">datasets</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="nf">extend_or_append</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span>
            <span class="n">datasets</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">datasets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">others</span><span class="p">:</span>
        <span class="n">extend_or_append</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">datasets</span>



<span class="k">class</span> <span class="nc">_MultiSourceDataset</span><span class="p">(</span><span class="n">Dataset</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">_merge_multisource</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>


<div class="viewcode-block" id="UnionDataset"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.UnionDataset">[docs]</a><span class="k">class</span> <span class="nc">UnionDataset</span><span class="p">(</span><span class="n">_MultiSourceDataset</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">*</span><span class="n">others</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">UnionDataset</span><span class="p">((</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">+</span> <span class="n">others</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">parts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">parts</span><span class="p">()</span> <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">UnionPartition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">part</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">part</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parts</span><span class="p">))</span></div>



<span class="k">class</span> <span class="nc">UnionPartition</span><span class="p">(</span><span class="n">Partition</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>



<div class="viewcode-block" id="CartesianProductDataset"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.CartesianProductDataset">[docs]</a><span class="k">class</span> <span class="nc">CartesianProductDataset</span><span class="p">(</span><span class="n">_MultiSourceDataset</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">product</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">*</span><span class="n">others</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CartesianProductDataset</span><span class="p">((</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">+</span> <span class="n">others</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">parts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">part_pairs</span> <span class="o">=</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">parts</span><span class="p">()</span> <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">CartesianProductPartition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">parts</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">parts</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">part_pairs</span><span class="p">)]</span></div>



<span class="k">class</span> <span class="nc">CartesianProductPartition</span><span class="p">(</span><span class="n">Partition</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield from</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span> <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="p">))</span>



<div class="viewcode-block" id="TransformingDataset"><a class="viewcode-back" href="../../../reference/compute/dataset.html#bndl.compute.dataset.TransformingDataset">[docs]</a><span class="k">class</span> <span class="nc">TransformingDataset</span><span class="p">(</span><span class="n">Dataset</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="o">*</span><span class="n">funcs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">funcs</span> <span class="o">=</span> <span class="n">funcs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pickle_funcs</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">parts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">TransformingPartition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">part</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">part</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="o">.</span><span class="n">parts</span><span class="p">())</span>
        <span class="p">]</span>


    <span class="k">def</span> <span class="nf">map_partitions_with_part</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cached</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">TransformingDataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">callsite</span> <span class="o">=</span> <span class="n">get_callsite</span><span class="p">(</span><span class="n">__file__</span><span class="p">)</span>
            <span class="c1"># TODO name = self.callsite[0] + &#39; -&gt; &#39; + name</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">funcs</span> <span class="o">+</span> <span class="p">(</span><span class="n">func</span><span class="p">,)</span>
            <span class="n">dset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_with</span><span class="p">(</span><span class="n">funcs</span><span class="o">=</span><span class="n">funcs</span><span class="p">,</span> <span class="n">callsite</span><span class="o">=</span><span class="n">callsite</span><span class="p">)</span>
            <span class="n">dset</span><span class="o">.</span><span class="n">_pickle_funcs</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">dset</span>


    <span class="k">def</span> <span class="nf">_pickle_funcs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_funcs</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">funcs</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">PicklingError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_funcs</span> <span class="o">=</span> <span class="n">cloudpickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">funcs</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">state</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;funcs&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">state</span>


    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">funcs</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_funcs</span><span class="p">)</span></div>



<span class="k">class</span> <span class="nc">TransformingPartition</span><span class="p">(</span><span class="n">Partition</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dset</span><span class="o">.</span><span class="n">funcs</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="p">,</span> <span class="n">data</span> <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">())</span>
        <span class="k">return</span> <span class="n">data</span>



<div class="viewcode-block" id="BarrierTask"><a class="viewcode-back" href="../../../reference/compute/execute.html#bndl.compute.dataset.BarrierTask">[docs]</a><span class="k">class</span> <span class="nc">BarrierTask</span><span class="p">(</span><span class="n">Task</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    An &#39;artificial&#39; task which disconnects</span>
<span class="sd">    :class:`ComputePartitionTasks &lt;bndl.compute.dataset.ComputePartitionTask&gt;` in order to reduce</span>
<span class="sd">    computational complexity in :mod:`bndl.execute.scheduler`. As this scheduler tracks individual</span>
<span class="sd">    dependencies the scheduling overhead goes through the roof when even a moderate amount of tasks</span>
<span class="sd">    which depend on another set of tasks (which is the case for a shuffle). E.g. consider</span>

<span class="sd">    .. code:: python</span>

<span class="sd">        ctx.range(1000, pcount=1000).map(lambda i: (i//10, i)).aggregate_by_key(sum).count()</span>

<span class="sd">    This would result in 1000 mapper and 1000 reducer tasks and thus in 1.000.000 dependencies to</span>
<span class="sd">    be tracked. After introducing the BarrierTask, there are 1000 + 1000 + 1 tasks and 1000 + 1000</span>
<span class="sd">    dependencies to track.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dependency_locations</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scheduler</span><span class="p">,</span> <span class="n">worker</span><span class="p">):</span>
        <span class="c1"># administer where dependencies were executed</span>
        <span class="n">by_worker</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dependency_locations</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dependencies</span><span class="p">:</span>
            <span class="n">executed_on</span> <span class="o">=</span> <span class="n">dep</span><span class="o">.</span><span class="n">executed_on_last</span><span class="p">()</span>
            <span class="n">locs</span> <span class="o">=</span> <span class="n">by_worker</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">executed_on</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">locs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">by_worker</span><span class="p">[</span><span class="n">executed_on</span><span class="p">]</span> <span class="o">=</span> <span class="n">locs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">part</span> <span class="o">=</span> <span class="n">dep</span><span class="o">.</span><span class="n">part</span>
            <span class="n">locs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">part</span><span class="o">.</span><span class="n">dset</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">part</span><span class="o">.</span><span class="n">idx</span><span class="p">))</span>
        <span class="c1"># &#39;execute&#39; the barrier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_executing</span><span class="p">(</span><span class="n">worker</span><span class="p">)</span>
        <span class="n">future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">future</span> <span class="o">=</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">Future</span><span class="p">()</span>
        <span class="n">future</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">signal_stop</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">future</span></div>


<div class="viewcode-block" id="ComputePartitionTask"><a class="viewcode-back" href="../../../reference/compute/execute.html#bndl.compute.dataset.ComputePartitionTask">[docs]</a><span class="k">class</span> <span class="nc">ComputePartitionTask</span><span class="p">(</span><span class="n">RmiTask</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A RMI task to compute a partition (and it&#39;s &#39;narrow&#39; sources). It adds some dependency location</span>
<span class="sd">    tracking and communications as well as memorizing where a partition was computed and cached.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">part</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;[_.]&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">part</span><span class="o">.</span><span class="n">dset</span><span class="o">.</span><span class="n">callsite</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">dset</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">dset</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">part</span><span class="o">.</span><span class="n">idx</span><span class="p">),</span> <span class="n">_compute_part</span><span class="p">,</span> <span class="p">[</span><span class="n">part</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">{},</span>
                         <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="n">part</span><span class="o">.</span><span class="n">dset</span><span class="o">.</span><span class="n">callsite</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">part</span> <span class="o">=</span> <span class="n">part</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">locality</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">locality</span>


    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scheduler</span><span class="p">,</span> <span class="n">worker</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dependencies</span><span class="p">:</span>
            <span class="c1"># created mapping of worker -&gt; list[part_id] for dependency locations</span>
            <span class="n">dependency_locations</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">barrier</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dependencies</span><span class="p">:</span>
                <span class="n">dependency_locations</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">barrier</span><span class="o">.</span><span class="n">dependency_locations</span><span class="p">)</span>
            <span class="c1"># set locations as second arguments to _compute_part</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dependency_locations</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">scheduler</span><span class="p">,</span> <span class="n">worker</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">signal_stop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dependencies</span><span class="p">:</span>
            <span class="n">exc</span> <span class="o">=</span> <span class="n">root_exc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exception</span><span class="p">())</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="n">DependenciesFailed</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="n">FailedDependency</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Marking barrier </span><span class="si">%r</span><span class="s1"> before </span><span class="si">%r</span><span class="s1"> as failed&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dependencies</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dependencies</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mark_failed</span><span class="p">(</span><span class="n">FailedDependency</span><span class="p">())</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">signal_stop</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">release</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">succeeded</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">part</span><span class="o">.</span><span class="n">save_cache_location</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">executed_on_last</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">part</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">release</span><span class="p">()</span></div>



<div class="viewcode-block" id="_compute_part"><a class="viewcode-back" href="../../../reference/compute/execute.html#bndl.compute.dataset._compute_part">[docs]</a><span class="k">def</span> <span class="nf">_compute_part</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">dependency_locations</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute a partition; this method calls compute for a partition (which calls comppute on its</span>
<span class="sd">    source partition(s), reads data from some external source, from cache, from other workers,</span>
<span class="sd">    etc.). This method is the method to execute by :class:`bndl.compute.dataset.ComputePartitionTask`</span>
<span class="sd">    (which delegates the RMI part to :class:`bndl.execute.jobs.RmiTask`.</span>

<span class="sd">    Args:</span>
<span class="sd">        part: The partition to compute.</span>
<span class="sd">        dependency_locations (mapping[str,object]): A mapping of worker name to a sequence of</span>
<span class="sd">            partition ids executed by this worker.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># communicate out of band on which workers dependencies of this task were executed</span>
        <span class="n">task_context</span><span class="p">()[</span><span class="s1">&#39;dependency_locations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dependency_locations</span>
        <span class="c1"># generate data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="c1"># &#39;materialize&#39; iterators and such for pickling</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_stable_iterable</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span>
    <span class="k">except</span> <span class="n">TaskCancelled</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">except</span> <span class="n">DependenciesFailed</span><span class="p">:</span>
        <span class="k">raise</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Error while computing part </span><span class="si">%s</span><span class="s1"> on worker </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                    <span class="n">part</span><span class="p">,</span> <span class="n">current_worker</span><span class="p">(),</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">raise</span></div>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; <a href="../../../copyright.html">Copyright</a> 2016, Frens Jan Rumph.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.3.5.dev1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>