from bndl.util.cython import try_pyximport_install ; try_pyximport_install()

import collections
import marshal
import pickle
import sys
import types

from bndl.util.marshalable import marshalable  # @UnresolvedImport, cython import
import cloudpickle


# TODO investigate performance of snappy in a cluster
# import snappy
def dumps(obj):
    marshalled = False
    if marshalable(obj):
        try:
            serialized = marshal.dumps(obj)
            marshalled = True
        except ValueError:
            marshalled = False

    if not marshalled:
        try:
            serialized = pickle.dumps(obj, protocol=4)
        except pickle.PicklingError:
            serialized = cloudpickle.dumps(obj, protocol=4)

    # serialized = snappy.compress(serialized)
    fmt = int(marshalled).to_bytes(1, sys.byteorder)

    return fmt, serialized


def loads(fmt, msg):
    marshalled = int.from_bytes(fmt, sys.byteorder)
    # msg = snappy.uncompress(msg)
    if marshalled:
        return marshal.loads(msg)
    else:
        return pickle.loads(msg)



# Hook namedtuple, make it picklable
# From https://github.com/apache/spark/blob/d6dc12ef0146ae409834c78737c116050961f350/python/pyspark/serializers.py



__cls = {}


def _restore(name, fields, value):
    """ Restore an object of namedtuple"""
    k = (name, fields)
    cls = __cls.get(k)
    if cls is None:
        cls = collections.namedtuple(name, fields)
        __cls[k] = cls
    return cls(*value)


def _hack_namedtuple(cls):
    """ Make class generated by namedtuple picklable """
    name = cls.__name__
    fields = cls._fields

    def __reduce__(self):
        return (_restore, (name, fields, tuple(self)))
    cls.__reduce__ = __reduce__
    cls._is_namedtuple_ = True
    return cls


def _hijack_namedtuple():
    """ Hack namedtuple() to make it picklable """
    # hijack only one time
    if hasattr(collections.namedtuple, "__hijack"):
        return

    global _old_namedtuple  # or it will put in closure

    def _copy_func(f):
        return types.FunctionType(f.__code__, f.__globals__, f.__name__,
                                  f.__defaults__, f.__closure__)

    _old_namedtuple = _copy_func(collections.namedtuple)

    def namedtuple(*args, **kwargs):
        cls = _old_namedtuple(*args, **kwargs)
        return _hack_namedtuple(cls)

#     # replace namedtuple with new one
    collections.namedtuple.__globals__["_old_namedtuple"] = _old_namedtuple  # @UndefinedVariable
    collections.namedtuple.__globals__["_hack_namedtuple"] = _hack_namedtuple  # @UndefinedVariable
    collections.namedtuple.__code__ = namedtuple.__code__
    collections.namedtuple.__hijack = 1

    # hack the cls already generated by namedtuple
    # those created in other module can be pickled as normal,
    # so only hack those in __main__ module
    for o in sys.modules["__main__"].__dict__.values():
        if (type(o) is type and o.__base__ is tuple
                and hasattr(o, "_fields")
                and "__reduce__" not in o.__dict__):
            _hack_namedtuple(o)  # hack inplace

_hijack_namedtuple()